#version 450

layout(local_size_x = 32) in;

struct Particle {
    vec3 position;
    vec3 velocity;
    vec3 scale;
    float lifeTime;
};

layout(std430, binding = 0) buffer ParticleBuffer {
    Particle particles[];
};

layout(push_constant) uniform PushConstants {
    mat4 modelMatrix;
    float deltaTime;
} pushConstants;

// Simple random number generator
float rand(vec2 co){
    return fract(sin(dot(co.xy , vec2(12.9898,78.233))) * 43758.5453);
}

const vec3 gravity = vec3(0.0, -2.81, 0.0); // Gravity vector

void main() {
    uint id = gl_GlobalInvocationID.x; // Get the current particle ID
    if (id >= particles.length()) return;
    Particle p = particles[id];

    // Initialize or reinitialize the particle
    if (p.lifeTime <= 0.0) {
        vec3 initialPosition = vec3(rand(vec2(id, 0.0)) * 1.0 - 0.5,
        rand(vec2(id, 1.0)) * 1.0 - 0.5,
        rand(vec2(id, 2.0)) * 1.0 - 0.5);
        p.position = (pushConstants.modelMatrix * vec4(initialPosition, 1.0)).xyz;
     //   p.position = initialPosition;

        p.velocity = vec3(rand(vec2(id, 0.0)) * 2.0 - 1.0,
        rand(vec2(id, 1.0)) * 2.0 - 1.0,
        rand(vec2(id, 2.0)) * 2.0 - 1.0); // Random direction
        float randScale = 1.0f + (rand(vec2(id, pushConstants.deltaTime)) * 2);
        p.scale = vec3(randScale, randScale, randScale); // Random scale
        p.lifeTime = 2.0; // Reset lifeTime
    } else {
        // Update the particle
        p.velocity += gravity * pushConstants.deltaTime; // Apply gravity
        p.position += p.velocity * pushConstants.deltaTime; // Update position
        p.lifeTime -= pushConstants.deltaTime; // Decrease lifeTime
        p.scale = vec3(1.0f + p.lifeTime); // Scale particle
    }

    particles[id] = p; // Write back updated particle
}

